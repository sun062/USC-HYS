<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Brainlink 데이터 분류기</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <!-- SheetJS (xlsx) for creating Excel files and reading both CSV and XLSX -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.17.0/xlsx.full.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        body { font-family: 'Inter', sans-serif; background-color: #f4f7f9; }
        .card { box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); }
        .btn-primary { transition: all 0.2s; }
        .btn-primary:hover { background-color: #1a56db; transform: translateY(-1px); }
        .loading { border-top-color: #3b82f6; animation: spin 1s ease-in-out infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body class="flex items-center justify-center min-h-screen p-4">

    <div class="card bg-white p-8 rounded-xl max-w-lg w-full">
        <h1 class="text-3xl font-bold text-gray-800 mb-6 text-center">Brainlink 데이터 분류 도구</h1>
        <p class="text-gray-600 mb-6 text-center">
            CSV 또는 XLSX 파일을 업로드하면 'Tag/备注' 열을 기준으로 '영문이름' 그룹과 '영문이름(caf)' 그룹으로 분류하여 두 개의 엑셀 파일로 출력합니다.
        </p>

        <input type="file" id="fileInput" accept=".csv, .xlsx" multiple
               class="block w-full text-sm text-gray-900 border border-gray-300 rounded-lg cursor-pointer bg-gray-50 p-3 mb-6
                      file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0
                      file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700
                      hover:file:bg-blue-100" />

        <button id="processButton" onclick="processFiles()"
                class="btn-primary w-full px-4 py-3 bg-blue-600 text-white font-semibold rounded-lg shadow-md
                       focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 flex items-center justify-center"
                       disabled>
            <span id="buttonText">파일 분류 및 엑셀 출력</span>
            <div id="loadingSpinner" class="loading w-5 h-5 border-2 rounded-full hidden ml-3"></div>
        </button>

        <div id="statusMessage" class="mt-6 p-4 rounded-lg text-sm hidden"></div>
        
        <div id="downloadArea" class="mt-6 space-y-3">
            <!-- Download links will appear here -->
        </div>

    </div>

    <script>
        // 상수 설정
        const TAG_COLUMN_NAME = 'Tag/备注';
        // 파일 이름이 CSV 파일명이든, XLSX 파일 내부의 시트 이름이든 동일하게 처리
        const DATA_IDENTIFIER_LONG = 'Long_Format_Data';
        const DATA_IDENTIFIER_SUMMARY = 'Summary_Statistics';
        
        // 원본 파일 이름 (사용자가 업로드하는 CSV 또는 XLSX 파일 이름과 일치해야 함)
        const FILENAME_LONG_DATA = 'analyzed_brainlink_data.xlsx - Long_Format_Data.csv';
        const FILENAME_SUMMARY_DATA = 'analyzed_brainlink_data.xlsx - Summary_Statistics.csv';

        const fileInput = document.getElementById('fileInput');
        const processButton = document.getElementById('processButton');
        const buttonText = document.getElementById('buttonText');
        const loadingSpinner = document.getElementById('loadingSpinner');
        const statusMessage = document.getElementById('statusMessage');
        const downloadArea = document.getElementById('downloadArea');

        // 파일 캐시를 사용하여 데이터 타입을 저장
        // { identifier: { data: [], headers: [] } }
        let dataCache = {}; 

        // 1. 파일 입력 변경 감지
        fileInput.addEventListener('change', (event) => {
            dataCache = {};
            downloadArea.innerHTML = '';
            statusMessage.classList.add('hidden');
            
            const files = event.target.files;
            // .xlsx 또는 .csv 파일을 하나라도 선택했는지 확인
            const validFiles = Array.from(files).filter(file => file.name.endsWith('.csv') || file.name.endsWith('.xlsx'));

            if (validFiles.length > 0) {
                processButton.disabled = false;
            } else {
                processButton.disabled = true;
            }
        });

        // 2. 파일 처리 시작 함수
        async function processFiles() {
            processButton.disabled = true;
            buttonText.textContent = '처리 중...';
            loadingSpinner.classList.remove('hidden');
            downloadArea.innerHTML = '';
            showStatus('데이터를 읽고 분류 중입니다...', 'bg-yellow-100 text-yellow-800');

            try {
                // 1. CSV/XLSX 데이터 읽기 및 캐시
                await readAndCacheFiles(fileInput.files);

                // 2. 필수 데이터 확인
                const longDataEntry = dataCache[DATA_IDENTIFIER_LONG];
                const summaryDataEntry = dataCache[DATA_IDENTIFIER_SUMMARY];

                if (!longDataEntry || !summaryDataEntry) {
                    throw new Error(`필수 데이터 시트(Long_Format_Data, Summary_Statistics)가 모두 포함된 파일을 업로드했는지 확인해주세요.`);
                }
                
                const longData = longDataEntry.data;
                const summaryData = summaryDataEntry.data;
                const longDataHeaders = longDataEntry.headers;
                const summaryDataHeaders = summaryDataEntry.headers;

                // 3. 데이터 분류 및 엑셀 워크북 생성
                const noCafWorkbook = createWorkbook(longData, summaryData, longDataHeaders, summaryDataHeaders, false); // 영문이름 그룹
                const cafWorkbook = createWorkbook(longData, summaryData, longDataHeaders, summaryDataHeaders, true); // 영문이름(caf) 그룹

                // 4. 파일 저장 및 다운로드 링크 생성
                saveWorkbook(noCafWorkbook, 'English_Name_Data.xlsx');
                saveWorkbook(cafWorkbook, 'English_Name_CAF_Data.xlsx');

                showStatus('분류된 엑셀 파일이 성공적으로 생성되었습니다. 아래 다운로드 링크를 확인해주세요.', 'bg-green-100 text-green-800');

            } catch (error) {
                console.error(error);
                showStatus(`오류 발생: ${error.message}`, 'bg-red-100 text-red-800');
            } finally {
                processButton.disabled = false;
                buttonText.textContent = '파일 분류 및 엑셀 출력';
                loadingSpinner.classList.add('hidden');
            }
        }
        
        // 3. 업로드된 파일을 읽고 dataCache에 저장하는 비동기 함수
        async function readAndCacheFiles(files) {
            dataCache = {}; // 캐시 초기화

            for (const file of Array.from(files)) {
                const extension = file.name.split('.').pop().toLowerCase();
                
                if (extension === 'csv') {
                    // CSV 파일은 PapaParse로 읽음
                    const data = await parseCsvFile(file);
                    // 파일 이름에서 시트 이름 추출
                    const identifierMatch = file.name.match(/(Long_Format_Data|Summary_Statistics)/i);
                    const identifier = identifierMatch ? identifierMatch[0] : file.name;

                    if (data.length > 0) {
                         // CSV는 header가 이미 data 객체의 키가 되므로 keys를 추출
                         const headers = Object.keys(data[0]);
                         dataCache[identifier] = { data: data, headers: headers };
                    }
                    
                } else if (extension === 'xlsx') {
                    // XLSX 파일은 SheetJS로 읽고 각 시트를 처리
                    await parseXlsxFile(file);
                }
            }
        }

        // 4. PapaParse를 사용하여 CSV 파일을 파싱하는 비동기 함수
        function parseCsvFile(file) {
            return new Promise((resolve, reject) => {
                Papa.parse(file, {
                    header: true, // 첫 행을 헤더로 사용
                    dynamicTyping: false,
                    skipEmptyLines: true,
                    complete: (results) => {
                        if (results.errors.length) {
                             console.warn("Parsing errors encountered:", results.errors);
                        }
                        resolve(results.data);
                    },
                    error: (error) => {
                        reject(new Error(`CSV 파일 파싱 중 오류 발생: ${file.name}: ${error.message}`));
                    }
                });
            });
        }
        
        // 5. SheetJS를 사용하여 XLSX 파일을 파싱하고 시트를 캐시에 저장하는 비동기 함수
        function parseXlsxFile(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const data = new Uint8Array(e.target.result);
                        const workbook = XLSX.read(data, { type: 'array' });

                        workbook.SheetNames.forEach(sheetName => {
                            // 시트 이름이 필요한 식별자(Long_Format_Data, Summary_Statistics)와 일치하는지 확인
                            if (sheetName.includes(DATA_IDENTIFIER_LONG) || sheetName.includes(DATA_IDENTIFIER_SUMMARY)) {
                                const ws = workbook.Sheets[sheetName];
                                // 시트를 JSON 형식으로 변환 (헤더 포함)
                                const jsonData = XLSX.utils.sheet_to_json(ws);
                                
                                if (jsonData.length > 0) {
                                    const headers = Object.keys(jsonData[0]);
                                    dataCache[sheetName] = { data: jsonData, headers: headers };
                                }
                            }
                        });
                        resolve();
                    } catch (err) {
                        reject(new Error(`XLSX 파일 처리 중 오류 발생: ${file.name}: ${err.message}`));
                    }
                };
                reader.onerror = (err) => {
                    reject(new Error(`XLSX 파일 읽기 중 오류 발생: ${file.name}: ${err.message}`));
                };
                reader.readAsArrayBuffer(file);
            });
        }


        // 6. 데이터 분류 및 엑셀 워크북 생성 함수
        function createWorkbook(longData, summaryData, longDataHeaders, summaryDataHeaders, isCaf) {
            // 필터링 기준 문자열
            const filterString = isCaf ? '(caf)' : '(caf)';
            const containsCaf = isCaf;

            // 롱 데이터 필터링: 'Tag/备注' 열 기준
            const filteredLongData = longData.filter(row => {
                const tag = row[TAG_COLUMN_NAME] || '';
                // 띄어쓰기를 무시하고 비교하기 위해 trim() 및 toLowerCase() 사용
                const normalizedTag = tag.trim(); 
                return containsCaf ? normalizedTag.includes(filterString) : !normalizedTag.includes(filterString);
            });

            // 요약 데이터 필터링: 'Session Tag' 열 기준
            const filteredSummaryData = summaryData.filter(row => {
                const tag = row['Session Tag'] || ''; 
                const normalizedTag = tag.trim();
                return containsCaf ? normalizedTag.includes(filterString) : !normalizedTag.includes(filterString);
            });
            
            // JSON 데이터를 배열 of 배열 (AOA) 형식으로 변환 (헤더 포함)
            const longAOA = jsonToAoa(filteredLongData, longDataHeaders);
            const summaryAOA = jsonToAoa(filteredSummaryData, summaryDataHeaders);

            // XLSX 워크북 생성
            const wb = XLSX.utils.book_new();

            // 시트 추가 (데이터가 없더라도 헤더를 포함한 빈 시트 추가)
            const ws_long = XLSX.utils.aoa_to_sheet(longAOA.length > 1 ? longAOA : [longDataHeaders]);
            XLSX.utils.book_append_sheet(wb, ws_long, "Long_Format_Data");

            const ws_summary = XLSX.utils.aoa_to_sheet(summaryAOA.length > 1 ? summaryAOA : [summaryDataHeaders]);
            XLSX.utils.book_append_sheet(wb, ws_summary, "Summary_Statistics");
            
            return wb;
        }

        // 7. JSON 배열을 배열 of 배열 (AOA) 형식으로 변환하는 헬퍼 함수
        function jsonToAoa(data, headers) {
            if (data.length === 0) {
                 return headers.length > 0 ? [headers] : [];
            }
            
            // 헤더 행
            const headerRow = headers;
            
            // 데이터 행
            const contentRows = data.map(row => 
                headers.map(header => row[header] === undefined ? '' : row[header])
            );
            
            return [headerRow, ...contentRows];
        }

        // 8. 워크북을 파일로 저장하고 다운로드 링크를 생성하는 함수
        function saveWorkbook(wb, filename) {
            const wbout = XLSX.write(wb, { bookType: 'xlsx', type: 'array' });
            const blob = new Blob([wbout], { type: 'application/octet-stream' });
            
            const url = URL.createObjectURL(blob);

            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            link.textContent = `다운로드: ${filename}`;
            link.className = 'block text-center px-4 py-2 bg-green-500 text-white font-medium rounded-lg hover:bg-green-600 transition duration-150';
            
            downloadArea.appendChild(link);
        }

        // 9. 상태 메시지를 표시하는 함수
        function showStatus(message, className) {
            statusMessage.textContent = message;
            statusMessage.className = `mt-6 p-4 rounded-lg text-sm ${className}`;
            statusMessage.classList.remove('hidden');
        }

        // 초기 상태 설정
        document.addEventListener('DOMContentLoaded', () => {
            processButton.disabled = true; // 파일이 선택될 때까지 버튼 비활성화
        });

    </script>
</body>
</html>
